# ğŸ§­ Flask Mastery Series â€“ Part III: Routing, Blueprints & Application Structure

---

## ğŸ“˜ Table of Contents

1. [Introduction](#introduction)
2. [Routing Fundamentals](#routing-fundamentals)

   * [Defining Routes](#defining-routes)
   * [Dynamic Routes](#dynamic-routes)
   * [URL Building with `url_for`](#url-building-with-url_for)
   * [Redirects & HTTP Methods](#redirects--http-methods)
3. [Error Handling & Custom Responses](#error-handling--custom-responses)
4. [Blueprints â€” Modular Application Design](#blueprints--modular-application-design)

   * [Creating and Registering Blueprints](#creating-and-registering-blueprints)
   * [Organizing API and Web Modules](#organizing-api-and-web-modules)
5. [The Application Factory Pattern](#the-application-factory-pattern)
6. [Config Management with Environments](#config-management-with-environments)
7. [Project Folder Structure Example](#project-folder-structure-example)
8. [Best Practices for Large Flask Apps](#best-practices-for-large-flask-apps)
9. [Next Steps](#next-steps)

---

## ğŸ§  Introduction

Flaskâ€™s flexibility allows small apps to scale into large modular systems. In this part, youâ€™ll learn **routing best practices**, **blueprint modularization**, and the **application factory pattern** â€” the foundation for scalable Flask architectures.

---

## ğŸ›£ï¸ Routing Fundamentals

### Defining Routes

A route binds a URL to a function.

```py
@app.route('/')
def home():
    return 'Welcome to Flask Mastery!'
```

### Dynamic Routes

Capture URL variables using angle brackets:

```py
@app.route('/user/<username>')
def profile(username):
    return f'Hello, {username}!'

@app.route('/post/<int:post_id>')
def post(post_id):
    return f'Viewing post #{post_id}'
```

> You can specify types: `string`, `int`, `float`, `path`, `uuid`.

---

### URL Building with `url_for`

Never hardcode URLs â€” use Flaskâ€™s `url_for()` to generate them dynamically.

```py
from flask import url_for, redirect

@app.route('/redirect-home')
def redirect_home():
    return redirect(url_for('home'))
```

This ensures that if route names or paths change, references stay valid.

In templates:

```html
<a href="{{ url_for('profile', username='akash') }}">Visit Profile</a>
```

---

### Redirects & HTTP Methods

Specify allowed HTTP methods:

```py
@app.route('/submit', methods=['POST'])
def submit():
    return 'Form submitted!'
```

Redirect example:

```py
from flask import redirect

@app.route('/old')
def old():
    return redirect(url_for('new'))
```

---

## âš ï¸ Error Handling & Custom Responses

Use decorators to catch specific HTTP errors.

```py
@app.errorhandler(404)
def not_found(e):
    return {'error': 'Not Found'}, 404

@app.errorhandler(500)
def server_error(e):
    return {'error': 'Internal Server Error'}, 500
```

Custom error templates:

```
templates/
 â”œâ”€â”€ 404.html
 â””â”€â”€ 500.html
```

```py
@app.errorhandler(404)
def not_found(e):
    return render_template('404.html'), 404
```

---

## ğŸ§© Blueprints â€” Modular Application Design

Blueprints allow splitting large apps into components (auth, API, admin, etc.).

### Creating and Registering Blueprints

**1. Create Blueprint:**

```py
# app/auth/__init__.py
from flask import Blueprint

auth_bp = Blueprint('auth', __name__, url_prefix='/auth')

from . import routes
```

**2. Define routes:**

```py
# app/auth/routes.py
from . import auth_bp
from flask import render_template, redirect, url_for

@auth_bp.route('/login')
def login():
    return render_template('auth/login.html')

@auth_bp.route('/logout')
def logout():
    return redirect(url_for('auth.login'))
```

**3. Register Blueprint in main app:**

```py
# app/__init__.py
from flask import Flask
from app.auth import auth_bp

def create_app():
    app = Flask(__name__)
    app.register_blueprint(auth_bp)
    return app
```

Run app:

```bash
flask --app app:create_app run
```

---

### Organizing API and Web Modules

Typical blueprint-based separation:

```
app/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ api/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ routes.py
â”œâ”€â”€ web/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ routes.py
â””â”€â”€ auth/
    â”œâ”€â”€ __init__.py
    â””â”€â”€ routes.py
```

Each blueprint handles a clear domain (API endpoints, templates, or authentication).

---

## ğŸ—ï¸ The Application Factory Pattern

Factory pattern dynamically creates app instances with configuration flexibility.

```py
# app/__init__.py
def create_app(config_name='config.DevConfig'):
    app = Flask(__name__)
    app.config.from_object(config_name)

    from app.api import api_bp
    from app.auth import auth_bp
    app.register_blueprint(api_bp)
    app.register_blueprint(auth_bp)

    return app
```

Advantages:

* Environment-specific apps (dev/stage/prod)
* Easy testing and configuration overrides
* Lazy initialization of extensions

Run:

```bash
flask --app app:create_app run --debug
```

---

## âš™ï¸ Config Management with Environments

```py
# config.py
class BaseConfig:
    SECRET_KEY = 'supersecret'
    DEBUG = False

class DevConfig(BaseConfig):
    DEBUG = True
    SQLALCHEMY_DATABASE_URI = 'sqlite:///dev.db'

class ProdConfig(BaseConfig):
    SQLALCHEMY_DATABASE_URI = 'postgresql://user:pass@db:5432/app'
```

Switch environment dynamically:

```bash
export FLASK_CONFIG=config.ProdConfig
flask run
```

---

## ğŸ“ Project Folder Structure Example

```
flask-mastery/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ routes.py
â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ routes.py
â”‚   â”œâ”€â”€ web/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ routes.py
â”‚   â”œâ”€â”€ templates/
â”‚   â””â”€â”€ static/
â”œâ”€â”€ config.py
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ Dockerfile
â””â”€â”€ docker-compose.yml
```

---

## ğŸ§± Best Practices for Large Flask Apps

âœ… Use blueprints for modularization.
âœ… Always use an app factory for flexible config loading.
âœ… Keep routes lean â€” move logic to service or model layers.
âœ… Use environment-based configs and `.env` files.
âœ… Follow a consistent naming convention for blueprints and folders.

---

## ğŸš€ Next Steps

Continue to **Part IV â€“ Databases & ORM (SQLAlchemy + Flask-Migrate)**, where youâ€™ll integrate a database layer, manage models, and handle migrations.

---

*Prepared for the Flask Mastery Series â€” exportable in `.md`, `.pdf`, and `.docx` formats.*
